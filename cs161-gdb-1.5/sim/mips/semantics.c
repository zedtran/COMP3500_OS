/* This file is part of GDB.

   Copyright 2002 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
 
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.

   --

   This file was generated by the program igen */

#ifndef SEMANTICS_C
#define SEMANTICS_C


#include "sim-inline.c"

#if C_REVEALS_MODULE_P (ITABLE_INLINE)
#include "itable.c"
#else
#include "itable.h"
#endif

#if C_REVEALS_MODULE_P (IDECODE_INLINE)
#include "idecode.c"
#else
#include "idecode.h"
#endif

#if C_REVEALS_MODULE_P (SUPPORT_INLINE)
#include "support.c"
#else
#include "support.h"
#endif

#include "semantics.h"


EXTERN_SEMANTICS\
(instruction_address)
semantic_RSVD_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RSVD_SPECIAL
#undef RSVD_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX RSVD_SPECIAL
#undef MY_NAME
#define MY_NAME "RSVD_SPECIAL"

  /* Extraction: RSVD
       #define do-not-use-icache
       6.0x0,5.*,5.*,5.*,5.OP,6.0x5 */

#undef OP
#define OP ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 72 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.*,5.*,5.*,5.OP,6.0x5 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 94 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "rsvd %ld", \
                    (long) OP);
#line 89 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RSVD_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 96 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    SignalException (ReservedInstruction, instruction_0);
  }
#line 117 "semantics.c"
  return nia;
  /* Extraction: RSVD
       #undef do-not-use-icache
       6.0x0,5.*,5.*,5.*,5.OP,6.0x5 */

#undef OP
#line 124 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SYSCALL_SPECIAL (SIM_DESC sd,
                          instruction_word instruction_0,
                          instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SYSCALL_SPECIAL
#undef SYSCALL_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SYSCALL_SPECIAL
#undef MY_NAME
#define MY_NAME "SYSCALL_SPECIAL"

  /* Extraction: SYSCALL
       #define do-not-use-icache
       6.0x0,20.CODE,6.0xc */

#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 25, 6)) /* cache - extraction */
#line 147 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,20.CODE,6.0xc */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3597 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "syscall %#lx", \
                    (unsigned long) CODE);
#line 164 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SYSCALL_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3611 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    SignalException (SystemCall, instruction_0);
  }
#line 192 "semantics.c"
  return nia;
  /* Extraction: SYSCALL
       #undef do-not-use-icache
       6.0x0,20.CODE,6.0xc */

#undef CODE
#line 199 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BREAK_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BREAK_SPECIAL
#undef BREAK_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX BREAK_SPECIAL
#undef MY_NAME
#define MY_NAME "BREAK_SPECIAL"

  /* Extraction: BREAK
       #define do-not-use-icache
       6.0x0,20.CODE,6.0xd */

#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 25, 6)) /* cache - extraction */
#line 222 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,20.CODE,6.0xd */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1095 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "break %#lx", \
                    (unsigned long) CODE);
#line 239 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BREAK_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1109 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    /* Check for some break instruction which are reserved for use by the simulator.  */
    unsigned int break_code = instruction_0 & HALT_INSTRUCTION_MASK;
    if (break_code == (HALT_INSTRUCTION  & HALT_INSTRUCTION_MASK) ||
        break_code == (HALT_INSTRUCTION2 & HALT_INSTRUCTION_MASK))
      {
        sim_engine_halt (SD, CPU, NULL, cia,
                         sim_exited, (unsigned int)(A0 & 0xFFFFFFFF));
      }
    else if (break_code == (BREAKPOINT_INSTRUCTION  & HALT_INSTRUCTION_MASK) ||
             break_code == (BREAKPOINT_INSTRUCTION2 & HALT_INSTRUCTION_MASK))
      {
        if (STATE & simDELAYSLOT)
          PC = cia - 4; /* reference the branch instruction */
        else
          PC = cia;
        SignalException (BreakPoint, instruction_0);
      }

    else
      {
        /* If we get this far, we're not an instruction reserved by the sim.  Raise
    	 the exception. */
        SignalException (BreakPoint, instruction_0);
      }
  }
#line 290 "semantics.c"
  return nia;
  /* Extraction: BREAK
       #undef do-not-use-icache
       6.0x0,20.CODE,6.0xd */

#undef CODE
#line 297 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGE_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGE_SPECIAL
#undef TGE_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TGE_SPECIAL
#undef MY_NAME
#define MY_NAME "TGE_SPECIAL"

  /* Extraction: TGE
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x30 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 324 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x30 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3652 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tge r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 342 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGE_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3664 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if ((signed_word) GPR[RS] >= (signed_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 371 "semantics.c"
  return nia;
  /* Extraction: TGE
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x30 */

#undef RS
#undef RT
#undef CODE
#line 380 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGEU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGEU_SPECIAL
#undef TGEU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TGEU_SPECIAL
#undef MY_NAME
#define MY_NAME "TGEU_SPECIAL"

  /* Extraction: TGEU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x31 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 407 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x31 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3706 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tgeu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 425 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGEU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3718 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if ((unsigned_word) GPR[RS] >= (unsigned_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 454 "semantics.c"
  return nia;
  /* Extraction: TGEU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x31 */

#undef RS
#undef RT
#undef CODE
#line 463 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLT_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLT_SPECIAL
#undef TLT_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TLT_SPECIAL
#undef MY_NAME
#define MY_NAME "TLT_SPECIAL"

  /* Extraction: TLT
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x32 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 490 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x32 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3724 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlt r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 508 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLT_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3736 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if ((signed_word) GPR[RS] < (signed_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 537 "semantics.c"
  return nia;
  /* Extraction: TLT
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x32 */

#undef RS
#undef RT
#undef CODE
#line 546 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLTU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLTU_SPECIAL
#undef TLTU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TLTU_SPECIAL
#undef MY_NAME
#define MY_NAME "TLTU_SPECIAL"

  /* Extraction: TLTU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x33 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 573 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x33 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3778 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tltu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 591 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLTU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3790 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if ((unsigned_word) GPR[RS] < (unsigned_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 620 "semantics.c"
  return nia;
  /* Extraction: TLTU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x33 */

#undef RS
#undef RT
#undef CODE
#line 629 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TEQ_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TEQ_SPECIAL
#undef TEQ_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TEQ_SPECIAL
#undef MY_NAME
#define MY_NAME "TEQ_SPECIAL"

  /* Extraction: TEQ
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x34 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 656 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x34 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3616 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "teq r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 674 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TEQ_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3628 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 703 "semantics.c"
  return nia;
  /* Extraction: TEQ
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x34 */

#undef RS
#undef RT
#undef CODE
#line 712 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TNE_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TNE_SPECIAL
#undef TNE_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TNE_SPECIAL
#undef MY_NAME
#define MY_NAME "TNE_SPECIAL"

  /* Extraction: TNE
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x36 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 739 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x36 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3796 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tne r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 757 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TNE_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3808 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 786 "semantics.c"
  return nia;
  /* Extraction: TNE
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x36 */

#undef RS
#undef RT
#undef CODE
#line 795 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLLV_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLLV_SPECIAL
#undef SLLV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLLV_SPECIAL
#undef MY_NAME
#define MY_NAME "SLLV_SPECIAL"

  /* Extraction: SLLV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x4 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 822 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x4 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3203 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sllv r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 846 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLLV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3217 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_sllv (SD_, RS, RT, RD);
  }
#line 874 "semantics.c"
  return nia;
  /* Extraction: SLLV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x4 */

#undef RS
#undef RT
#undef RD
#line 883 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRLV_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRLV_SPECIAL
#undef SRLV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRLV_SPECIAL
#undef MY_NAME
#define MY_NAME "SRLV_SPECIAL"

  /* Extraction: SRLV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x6 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 910 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x6 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3428 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "srlv r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 934 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRLV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3442 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_srlv (SD_, RS, RT, RD);
  }
#line 962 "semantics.c"
  return nia;
  /* Extraction: SRLV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x6 */

#undef RS
#undef RT
#undef RD
#line 971 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRAV_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRAV_SPECIAL
#undef SRAV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRAV_SPECIAL
#undef MY_NAME
#define MY_NAME "SRAV_SPECIAL"

  /* Extraction: SRAV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x7 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 998 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x7 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3368 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "srav r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 1022 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRAV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3382 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_srav (SD_, RS, RT, RD);
  }
#line 1050 "semantics.c"
  return nia;
  /* Extraction: SRAV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x7 */

#undef RS
#undef RT
#undef RD
#line 1059 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVZ_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVZ_SPECIAL
#undef MOVZ_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MOVZ_SPECIAL
#undef MY_NAME
#define MY_NAME "MOVZ_SPECIAL"

  /* Extraction: MOVZ
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xa */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1086 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xa */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2536 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movz r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1110 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVZ_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2545 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if (GPR[RT] == 0)
      {
        GPR[RD] = GPR[RS];
        TRACE_ALU_RESULT (GPR[RD]);
      }
  }
#line 1142 "semantics.c"
  return nia;
  /* Extraction: MOVZ
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xa */

#undef RS
#undef RT
#undef RD
#line 1151 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVN_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVN_SPECIAL
#undef MOVN_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MOVN_SPECIAL
#undef MY_NAME
#define MY_NAME "MOVN_SPECIAL"

  /* Extraction: MOVN
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xb */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1178 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xb */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2517 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movn r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1202 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVN_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2526 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if (GPR[RT] != 0)
      {
        GPR[RD] = GPR[RS];
        TRACE_ALU_RESULT (GPR[RD]);
      }
  }
#line 1234 "semantics.c"
  return nia;
  /* Extraction: MOVN
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xb */

#undef RS
#undef RT
#undef RD
#line 1243 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADD_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADD_SPECIAL
#undef ADD_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX ADD_SPECIAL
#undef MY_NAME
#define MY_NAME "ADD_SPECIAL"

  /* Extraction: ADD
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x20 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1270 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x20 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 518 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "add r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1294 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADD_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 532 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
      Unpredictable ();
    TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
    {
      ALU32_BEGIN (GPR[RS]);
      ALU32_ADD (GPR[RT]);
      ALU32_END (GPR[RD]);   /* This checks for overflow.  */
    }
    TRACE_ALU_RESULT (GPR[RD]);
  }
#line 1330 "semantics.c"
  return nia;
  /* Extraction: ADD
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x20 */

#undef RS
#undef RT
#undef RD
#line 1339 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADDU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADDU_SPECIAL
#undef ADDU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX ADDU_SPECIAL
#undef MY_NAME
#define MY_NAME "ADDU_SPECIAL"

  /* Extraction: ADDU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x21 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1366 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x21 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 612 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "addu r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1390 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADDU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 626 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_addu (SD_, RS, RT, RD);
  }
#line 1418 "semantics.c"
  return nia;
  /* Extraction: ADDU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x21 */

#undef RS
#undef RT
#undef RD
#line 1427 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SUB_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SUB_SPECIAL
#undef SUB_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SUB_SPECIAL
#undef MY_NAME
#define MY_NAME "SUB_SPECIAL"

  /* Extraction: SUB
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x22 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1454 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x22 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3447 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sub r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1478 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SUB_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3461 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
      Unpredictable ();
    TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
    {
      ALU32_BEGIN (GPR[RS]);
      ALU32_SUB (GPR[RT]);
      ALU32_END (GPR[RD]);   /* This checks for overflow.  */
    }
    TRACE_ALU_RESULT (GPR[RD]);
  }
#line 1514 "semantics.c"
  return nia;
  /* Extraction: SUB
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x22 */

#undef RS
#undef RT
#undef RD
#line 1523 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SUBU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SUBU_SPECIAL
#undef SUBU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SUBU_SPECIAL
#undef MY_NAME
#define MY_NAME "SUBU_SPECIAL"

  /* Extraction: SUBU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x23 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1550 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x23 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3483 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "subu r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1574 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SUBU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3497 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_subu (SD_, RS, RT, RD);
  }
#line 1602 "semantics.c"
  return nia;
  /* Extraction: SUBU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x23 */

#undef RS
#undef RT
#undef RD
#line 1611 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_AND_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_AND_SPECIAL
#undef AND_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX AND_SPECIAL
#undef MY_NAME
#define MY_NAME "AND_SPECIAL"

  /* Extraction: AND
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x24 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1638 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x24 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 639 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "and r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1662 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_AND_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 653 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_and (SD_, RS, RT, RD);
  }
#line 1690 "semantics.c"
  return nia;
  /* Extraction: AND
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x24 */

#undef RS
#undef RT
#undef RD
#line 1699 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_OR_SPECIAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_OR_SPECIAL
#undef OR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX OR_SPECIAL
#undef MY_NAME
#define MY_NAME "OR_SPECIAL"

  /* Extraction: OR
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x25 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1726 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x25 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2772 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "or r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1750 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_OR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2786 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_or (SD_, RS, RT, RD);
  }
#line 1778 "semantics.c"
  return nia;
  /* Extraction: OR
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x25 */

#undef RS
#undef RT
#undef RD
#line 1787 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_XOR_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_XOR_SPECIAL
#undef XOR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX XOR_SPECIAL
#undef MY_NAME
#define MY_NAME "XOR_SPECIAL"

  /* Extraction: XOR
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x26 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1814 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x26 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3839 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "xor r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1838 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_XOR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3853 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_xor (SD_, RS, RT, RD);
  }
#line 1866 "semantics.c"
  return nia;
  /* Extraction: XOR
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x26 */

#undef RS
#undef RT
#undef RD
#line 1875 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_NOR_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_NOR_SPECIAL
#undef NOR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX NOR_SPECIAL
#undef MY_NAME
#define MY_NAME "NOR_SPECIAL"

  /* Extraction: NOR
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x27 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1902 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x27 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2746 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "nor r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1926 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_NOR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2760 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_nor (SD_, RS, RT, RD);
  }
#line 1954 "semantics.c"
  return nia;
  /* Extraction: NOR
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x27 */

#undef RS
#undef RT
#undef RD
#line 1963 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLT_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLT_SPECIAL
#undef SLT_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLT_SPECIAL
#undef MY_NAME
#define MY_NAME "SLT_SPECIAL"

  /* Extraction: SLT
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2a */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1990 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2a */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3229 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "slt r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2014 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLT_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3243 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_slt (SD_, RS, RT, RD);
  }
#line 2042 "semantics.c"
  return nia;
  /* Extraction: SLT
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2a */

#undef RS
#undef RT
#undef RD
#line 2051 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLTU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLTU_SPECIAL
#undef SLTU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLTU_SPECIAL
#undef MY_NAME
#define MY_NAME "SLTU_SPECIAL"

  /* Extraction: SLTU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2b */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 2078 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2b */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3308 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sltu r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2102 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLTU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3322 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_sltu (SD_, RS, RT, RD);
  }
#line 2130 "semantics.c"
  return nia;
  /* Extraction: SLTU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2b */

#undef RS
#undef RT
#undef RD
#line 2139 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MULT_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MULT_SPECIAL
#undef MULT_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MULT_SPECIAL
#undef MY_NAME
#define MY_NAME "MULT_SPECIAL"

  /* Extraction: MULT
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x18 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 2164 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x18 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2670 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mult r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2187 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MULT_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2682 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_mult (SD_, RS, RT, 0);
  }
#line 2215 "semantics.c"
  return nia;
  /* Extraction: MULT
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x18 */

#undef RS
#undef RT
#line 2223 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MULTU_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MULTU_SPECIAL
#undef MULTU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MULTU_SPECIAL
#undef MY_NAME
#define MY_NAME "MULTU_SPECIAL"

  /* Extraction: MULTU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x19 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 2248 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x19 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2713 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "multu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2271 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MULTU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2725 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_multu (SD_, RS, RT, 0);
  }
#line 2299 "semantics.c"
  return nia;
  /* Extraction: MULTU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x19 */

#undef RS
#undef RT
#line 2307 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DIV_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DIV_SPECIAL
#undef DIV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DIV_SPECIAL
#undef MY_NAME
#define MY_NAME "DIV_SPECIAL"

  /* Extraction: DIV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1a */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 2332 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x1a */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1443 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "div r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2355 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DIV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1457 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_div (SD_, RS, RT);
  }
#line 2383 "semantics.c"
  return nia;
  /* Extraction: DIV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1a */

#undef RS
#undef RT
#line 2391 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DIVU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DIVU_SPECIAL
#undef DIVU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DIVU_SPECIAL
#undef MY_NAME
#define MY_NAME "DIVU_SPECIAL"

  /* Extraction: DIVU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1b */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 2416 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x1b */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1484 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "divu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2439 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DIVU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1498 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_divu (SD_, RS, RT);
  }
#line 2467 "semantics.c"
  return nia;
  /* Extraction: DIVU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1b */

#undef RS
#undef RT
#line 2475 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVtf_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVtf_SPECIAL
#undef MOVtf_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MOVtf_SPECIAL
#undef MY_NAME
#define MY_NAME "MOVtf_SPECIAL"

  /* Extraction: MOVtf
       #define do-not-use-icache
       6.0x0,5.RS,3.CC,1.0x0,1.TF,5.RD,5.0x0,6.0x1 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 20, 18)) /* cache - extraction */
#undef TF
#define TF ((unsigned) EXTRACTED32 (instruction_0, 16, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 2504 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,3.CC,1.0x0,1.TF,5.RD,5.0x0,6.0x1 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000207c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4812 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mov%s r%ld, r%ld, %ld", \
                    str_TF (SD_, TF), \
                    (long) RD, \
                    (long) RS, \
                    (long) CC);
#line 2543 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVtf_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4821 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    check_fpu (SD_);
    if (GETFCC(CC) == TF)
      GPR[RD] = GPR[RS];
  }
#line 2573 "semantics.c"
  return nia;
  /* Extraction: MOVtf
       #undef do-not-use-icache
       6.0x0,5.RS,3.CC,1.0x0,1.TF,5.RD,5.0x0,6.0x1 */

#undef RS
#undef CC
#undef TF
#undef RD
#line 2583 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_JALR_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_JALR_SPECIAL
#undef JALR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX JALR_SPECIAL
#undef MY_NAME
#define MY_NAME "JALR_SPECIAL"

  /* Extraction: JALR
       #define do-not-use-icache
       6.0x0,5.RS,5.0x0,5.RD,5.0x0,6.0x9 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 2608 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.0x0,5.RD,5.0x0,6.0x9 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f07c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (RD == 31)
#line 1939 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "jalr r%ld", \
                      (long) RS);
#line 2631 "semantics.c"
      else
#line 1940 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "jalr r%ld, r%ld", \
                      (long) RD, \
                      (long) RS);
#line 2640 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_JALR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1954 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word temp = GPR[RS];
    GPR[RD] = CIA + 8;
    DELAY_SLOT (temp);
  }
#line 2670 "semantics.c"
  return nia;
  /* Extraction: JALR
       #undef do-not-use-icache
       6.0x0,5.RS,5.0x0,5.RD,5.0x0,6.0x9 */

#undef RS
#undef RD
#line 2678 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_JR_SPECIAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_JR_SPECIAL
#undef JR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX JR_SPECIAL
#undef MY_NAME
#define MY_NAME "JR_SPECIAL"

  /* Extraction: JR
       #define do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x8 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#line 2701 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,15.0x0,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001fffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1961 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "jr r%ld", \
                    (long) RS);
#line 2723 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_JR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1975 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    DELAY_SLOT (GPR[RS]);
  }
#line 2751 "semantics.c"
  return nia;
  /* Extraction: JR
       #undef do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x8 */

#undef RS
#line 2758 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTHI_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTHI_SPECIAL
#undef MTHI_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MTHI_SPECIAL
#undef MY_NAME
#define MY_NAME "MTHI_SPECIAL"

  /* Extraction: MTHI
       #define do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x11 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#line 2781 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,15.0x0,6.0x11 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001fffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2599 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mthi r%ld", \
                    (long) RS);
#line 2803 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTHI_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2609 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    check_mt_hilo (SD_, HIHISTORY);
    HI = GPR[RS];
  }
#line 2832 "semantics.c"
  return nia;
  /* Extraction: MTHI
       #undef do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x11 */

#undef RS
#line 2839 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTLO_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTLO_SPECIAL
#undef MTLO_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MTLO_SPECIAL
#undef MY_NAME
#define MY_NAME "MTLO_SPECIAL"

  /* Extraction: MTLO
       #define do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x13 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#line 2862 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,15.0x0,6.0x13 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001fffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2616 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mtlo r%ld", \
                    (long) RS);
#line 2884 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTLO_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2626 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    check_mt_hilo (SD_, LOHISTORY);
    LO = GPR[RS];
  }
#line 2913 "semantics.c"
  return nia;
  /* Extraction: MTLO
       #undef do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x13 */

#undef RS
#line 2920 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLLa_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLLa_SPECIAL
#undef SLLa_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLLa_SPECIAL
#undef MY_NAME
#define MY_NAME "SLLa_SPECIAL"

  /* Extraction: SLLa
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 2947 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (RD == 0 && RT == 0 && SHIFT == 0)
#line 3160 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "nop");
#line 2969 "semantics.c"
      else
#line 3161 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "sll r%ld, r%ld, %ld", \
                      (long) RD, \
                      (long) RT, \
                      (long) SHIFT);
#line 2979 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLLa_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3171 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    /* Skip shift for NOP, so that there won't be lots of extraneous
       trace output.  */
    if (RD != 0 || RT != 0 || SHIFT != 0)
      do_sll (SD_, RT, RD, SHIFT);
  }
#line 3010 "semantics.c"
  return nia;
  /* Extraction: SLLa
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x0 */

#undef RT
#undef RD
#undef SHIFT
#line 3019 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRL_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRL_SPECIAL
#undef SRL_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRL_SPECIAL
#undef MY_NAME
#define MY_NAME "SRL_SPECIAL"

  /* Extraction: SRL
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x2 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 3046 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x2 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3398 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "srl r%ld, r%ld, %ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) SHIFT);
#line 3070 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRL_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3412 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_srl (SD_, RT, RD, SHIFT);
  }
#line 3098 "semantics.c"
  return nia;
  /* Extraction: SRL
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x2 */

#undef RT
#undef RD
#undef SHIFT
#line 3107 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRA_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRA_SPECIAL
#undef SRA_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRA_SPECIAL
#undef MY_NAME
#define MY_NAME "SRA_SPECIAL"

  /* Extraction: SRA
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 3134 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3337 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sra r%ld, r%ld, %ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) SHIFT);
#line 3158 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRA_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3351 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_sra (SD_, RT, RD, SHIFT);
  }
#line 3186 "semantics.c"
  return nia;
  /* Extraction: SRA
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3 */

#undef RT
#undef RD
#undef SHIFT
#line 3195 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFHI_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFHI_SPECIAL
#undef MFHI_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MFHI_SPECIAL
#undef MY_NAME
#define MY_NAME "MFHI_SPECIAL"

  /* Extraction: MFHI
       #define do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x10 */

#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 3218 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,10.0x0,5.RD,5.0x0,6.0x10 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03ff07c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2477 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mfhi r%ld", \
                    (long) RD);
#line 3240 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFHI_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2487 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_mfhi (SD_, RD);
  }
#line 3268 "semantics.c"
  return nia;
  /* Extraction: MFHI
       #undef do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x10 */

#undef RD
#line 3275 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFLO_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFLO_SPECIAL
#undef MFLO_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MFLO_SPECIAL
#undef MY_NAME
#define MY_NAME "MFLO_SPECIAL"

  /* Extraction: MFLO
       #define do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x12 */

#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 3298 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,10.0x0,5.RD,5.0x0,6.0x12 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03ff07c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2501 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mflo r%ld", \
                    (long) RD);
#line 3320 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFLO_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2511 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_mflo (SD_, RD);
  }
#line 3348 "semantics.c"
  return nia;
  /* Extraction: MFLO
       #undef do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x12 */

#undef RD
#line 3355 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SYNC_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SYNC_SPECIAL
#undef SYNC_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SYNC_SPECIAL
#undef MY_NAME
#define MY_NAME "SYNC_SPECIAL"

  /* Extraction: SYNC
       #define do-not-use-icache
       6.0x0,15.0x0,5.STYPE,6.0xf */

#undef STYPE
#define STYPE ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 3378 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,15.0x0,5.STYPE,6.0xf */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03fff800) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (STYPE == 0)
#line 3578 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "sync");
#line 3400 "semantics.c"
      else
#line 3579 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "sync %ld", \
                      (long) STYPE);
#line 3408 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SYNC_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3592 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    SyncOperation (STYPE);
  }
#line 3436 "semantics.c"
  return nia;
  /* Extraction: SYNC
       #undef do-not-use-icache
       6.0x0,15.0x0,5.STYPE,6.0xf */

#undef STYPE
#line 3443 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZ_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZ_REGIMM
#undef BLTZ_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZ_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZ_REGIMM"

  /* Extraction: BLTZ
       #define do-not-use-icache
       6.0x1,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3468 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x0,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 938 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltz r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 3486 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZ_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 952 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 3518 "semantics.c"
  return nia;
  /* Extraction: BLTZ
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 3526 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZ_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZ_REGIMM
#undef BGEZ_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZ_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZ_REGIMM"

  /* Extraction: BGEZ
       #define do-not-use-icache
       6.0x1,5.RS,5.0x1,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3551 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x1,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 730 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgez r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 3569 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZ_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 744 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 3601 "semantics.c"
  return nia;
  /* Extraction: BGEZ
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x1,16.OFFSET */

#undef RS
#undef OFFSET
#line 3609 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZL_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZL_REGIMM
#undef BLTZL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZL_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZL_REGIMM"

  /* Extraction: BLTZL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x2,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3634 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x2,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1019 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltzl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 3652 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1032 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 3688 "semantics.c"
  return nia;
  /* Extraction: BLTZL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x2,16.OFFSET */

#undef RS
#undef OFFSET
#line 3696 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZL_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZL_REGIMM
#undef BGEZL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZL_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZL_REGIMM"

  /* Extraction: BGEZL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x3,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3721 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x3,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 811 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 3739 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 824 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 3773 "semantics.c"
  return nia;
  /* Extraction: BGEZL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x3,16.OFFSET */

#undef RS
#undef OFFSET
#line 3781 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGEI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGEI_REGIMM
#undef TGEI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TGEI_REGIMM
#undef MY_NAME
#define MY_NAME "TGEI_REGIMM"

  /* Extraction: TGEI
       #define do-not-use-icache
       6.0x1,5.RS,5.0x8,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3806 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x8,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3670 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tgei r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 3824 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGEI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3682 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if ((signed_word) GPR[RS] >= (signed_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 3853 "semantics.c"
  return nia;
  /* Extraction: TGEI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x8,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 3861 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGEIU_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGEIU_REGIMM
#undef TGEIU_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TGEIU_REGIMM
#undef MY_NAME
#define MY_NAME "TGEIU_REGIMM"

  /* Extraction: TGEIU
       #define do-not-use-icache
       6.0x1,5.RS,5.0x9,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3886 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x9,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3688 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tgeiu r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 3904 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGEIU_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3700 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if ((unsigned_word) GPR[RS] >= (unsigned_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 3933 "semantics.c"
  return nia;
  /* Extraction: TGEIU
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x9,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 3941 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLTI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLTI_REGIMM
#undef TLTI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TLTI_REGIMM
#undef MY_NAME
#define MY_NAME "TLTI_REGIMM"

  /* Extraction: TLTI
       #define do-not-use-icache
       6.0x1,5.RS,5.0xa,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 3966 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xa,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3742 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlti r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 3984 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLTI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3754 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if ((signed_word) GPR[RS] < (signed_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 4013 "semantics.c"
  return nia;
  /* Extraction: TLTI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xa,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 4021 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLTIU_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLTIU_REGIMM
#undef TLTIU_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TLTIU_REGIMM
#undef MY_NAME
#define MY_NAME "TLTIU_REGIMM"

  /* Extraction: TLTIU
       #define do-not-use-icache
       6.0x1,5.RS,5.0xb,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4046 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xb,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3760 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tltiu r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 4064 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLTIU_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3772 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if ((unsigned_word) GPR[RS] < (unsigned_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 4093 "semantics.c"
  return nia;
  /* Extraction: TLTIU
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xb,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 4101 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TEQI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TEQI_REGIMM
#undef TEQI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TEQI_REGIMM
#undef MY_NAME
#define MY_NAME "TEQI_REGIMM"

  /* Extraction: TEQI
       #define do-not-use-icache
       6.0x1,5.RS,5.0xc,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4126 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xc,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3634 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "teqi r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 4144 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TEQI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3646 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if ((signed_word) GPR[RS] == (signed_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 4173 "semantics.c"
  return nia;
  /* Extraction: TEQI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xc,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 4181 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TNEI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TNEI_REGIMM
#undef TNEI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TNEI_REGIMM
#undef MY_NAME
#define MY_NAME "TNEI_REGIMM"

  /* Extraction: TNEI
       #define do-not-use-icache
       6.0x1,5.RS,5.0xe,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4206 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xe,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3814 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tnei r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 4224 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TNEI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3826 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if ((signed_word) GPR[RS] != (signed_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 4253 "semantics.c"
  return nia;
  /* Extraction: TNEI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xe,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 4261 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZAL_REGIMM (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZAL_REGIMM
#undef BLTZAL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZAL_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZAL_REGIMM"

  /* Extraction: BLTZAL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x10,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4286 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x10,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 962 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltzal r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4304 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZAL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 976 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 4341 "semantics.c"
  return nia;
  /* Extraction: BLTZAL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x10,16.OFFSET */

#undef RS
#undef OFFSET
#line 4349 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZAL_REGIMM (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZAL_REGIMM
#undef BGEZAL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZAL_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZAL_REGIMM"

  /* Extraction: BGEZAL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x11,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4374 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x11,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 754 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezal r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4392 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZAL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 768 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 4427 "semantics.c"
  return nia;
  /* Extraction: BGEZAL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x11,16.OFFSET */

#undef RS
#undef OFFSET
#line 4435 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZALL_REGIMM (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZALL_REGIMM
#undef BLTZALL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZALL_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZALL_REGIMM"

  /* Extraction: BLTZALL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x12,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4460 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x12,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 991 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltzall r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4478 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZALL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1004 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 4515 "semantics.c"
  return nia;
  /* Extraction: BLTZALL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x12,16.OFFSET */

#undef RS
#undef OFFSET
#line 4523 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZALL_REGIMM (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZALL_REGIMM
#undef BGEZALL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZALL_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZALL_REGIMM"

  /* Extraction: BGEZALL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x13,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4548 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x13,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 781 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezall r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4566 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZALL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 794 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 4605 "semantics.c"
  return nia;
  /* Extraction: BGEZALL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x13,16.OFFSET */

#undef RS
#undef OFFSET
#line 4613 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_J_NORMAL (SIM_DESC sd,
                   instruction_word instruction_0,
                   instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_J_NORMAL
#undef J_NORMAL
#undef MY_PREFIX
#define MY_PREFIX J_NORMAL
#undef MY_NAME
#define MY_NAME "J_NORMAL"

  /* Extraction: J
       #define do-not-use-icache
       6.0x2,26.INSTR_INDEX */

#undef INSTR_INDEX
#define INSTR_INDEX ((unsigned) MASKED32 (instruction_0, 25, 0)) /* cache - extraction */
#line 4636 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2,26.INSTR_INDEX */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1895 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "j %ld", \
                    (long) INSTR_INDEX);
#line 4653 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_J_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1909 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    /* NOTE: The region used is that of the delay slot NIA and NOT the
       current instruction */
    address_word region = (NIA & MASK (63, 28));
    DELAY_SLOT (region | (INSTR_INDEX << 2));
  }
#line 4684 "semantics.c"
  return nia;
  /* Extraction: J
       #undef do-not-use-icache
       6.0x2,26.INSTR_INDEX */

#undef INSTR_INDEX
#line 4691 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_JAL_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_JAL_NORMAL
#undef JAL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX JAL_NORMAL
#undef MY_NAME
#define MY_NAME "JAL_NORMAL"

  /* Extraction: JAL
       #define do-not-use-icache
       6.0x3,26.INSTR_INDEX */

#undef INSTR_INDEX
#define INSTR_INDEX ((unsigned) MASKED32 (instruction_0, 25, 0)) /* cache - extraction */
#line 4714 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x3,26.INSTR_INDEX */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1917 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "jal %ld", \
                    (long) INSTR_INDEX);
#line 4731 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_JAL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1931 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    /* NOTE: The region used is that of the delay slot and NOT the
       current instruction */
    address_word region = (NIA & MASK (63, 28));
    GPR[31] = CIA + 8;
    DELAY_SLOT (region | (INSTR_INDEX << 2));
  }
#line 4763 "semantics.c"
  return nia;
  /* Extraction: JAL
       #undef do-not-use-icache
       6.0x3,26.INSTR_INDEX */

#undef INSTR_INDEX
#line 4770 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BEQ_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BEQ_NORMAL
#undef BEQ_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BEQ_NORMAL
#undef MY_NAME
#define MY_NAME "BEQ_NORMAL"

  /* Extraction: BEQ
       #define do-not-use-icache
       6.0x4,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4797 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x4,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 681 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "beq r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 4816 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BEQ_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 695 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 4848 "semantics.c"
  return nia;
  /* Extraction: BEQ
       #undef do-not-use-icache
       6.0x4,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#line 4857 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BNE_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BNE_NORMAL
#undef BNE_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BNE_NORMAL
#undef MY_NAME
#define MY_NAME "BNE_NORMAL"

  /* Extraction: BNE
       #define do-not-use-icache
       6.0x5,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4884 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x5,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1046 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bne r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 4903 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BNE_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1060 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 4935 "semantics.c"
  return nia;
  /* Extraction: BNE
       #undef do-not-use-icache
       6.0x5,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#line 4944 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLEZ_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLEZ_NORMAL
#undef BLEZ_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BLEZ_NORMAL
#undef MY_NAME
#define MY_NAME "BLEZ_NORMAL"

  /* Extraction: BLEZ
       #define do-not-use-icache
       6.0x6,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4969 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x6,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 887 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "blez r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4992 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLEZ_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 901 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] <= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 5026 "semantics.c"
  return nia;
  /* Extraction: BLEZ
       #undef do-not-use-icache
       6.0x6,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 5034 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGTZ_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGTZ_NORMAL
#undef BGTZ_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BGTZ_NORMAL
#undef MY_NAME
#define MY_NAME "BGTZ_NORMAL"

  /* Extraction: BGTZ
       #define do-not-use-icache
       6.0x7,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5059 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x7,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 836 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgtz r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 5082 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGTZ_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 850 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] > 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 5114 "semantics.c"
  return nia;
  /* Extraction: BGTZ
       #undef do-not-use-icache
       6.0x7,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 5122 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADDI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADDI_NORMAL
#undef ADDI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ADDI_NORMAL
#undef MY_NAME
#define MY_NAME "ADDI_NORMAL"

  /* Extraction: ADDI
       #define do-not-use-icache
       6.0x8,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5149 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x8,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 546 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "addi r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5168 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADDI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 560 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if (NotWordValue (GPR[RS]))
      Unpredictable ();
    TRACE_ALU_INPUT2 (GPR[RS], EXTEND16 (IMMEDIATE));
    {
      ALU32_BEGIN (GPR[RS]);
      ALU32_ADD (EXTEND16 (IMMEDIATE));
      ALU32_END (GPR[RT]);   /* This checks for overflow.  */
    }
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 5204 "semantics.c"
  return nia;
  /* Extraction: ADDI
       #undef do-not-use-icache
       6.0x8,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5213 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADDIU_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADDIU_NORMAL
#undef ADDIU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ADDIU_NORMAL
#undef MY_NAME
#define MY_NAME "ADDIU_NORMAL"

  /* Extraction: ADDIU
       #define do-not-use-icache
       6.0x9,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5240 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x9,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 583 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "addiu r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5259 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADDIU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 597 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_addiu (SD_, RS, RT, IMMEDIATE);
  }
#line 5287 "semantics.c"
  return nia;
  /* Extraction: ADDIU
       #undef do-not-use-icache
       6.0x9,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5296 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLTI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLTI_NORMAL
#undef SLTI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SLTI_NORMAL
#undef MY_NAME
#define MY_NAME "SLTI_NORMAL"

  /* Extraction: SLTI
       #define do-not-use-icache
       6.0xa,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5323 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xa,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3255 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "slti r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5342 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLTI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3269 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_slti (SD_, RS, RT, IMMEDIATE);
  }
#line 5370 "semantics.c"
  return nia;
  /* Extraction: SLTI
       #undef do-not-use-icache
       6.0xa,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5379 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLTIU_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLTIU_NORMAL
#undef SLTIU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SLTIU_NORMAL
#undef MY_NAME
#define MY_NAME "SLTIU_NORMAL"

  /* Extraction: SLTIU
       #define do-not-use-icache
       6.0xb,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5406 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xb,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3281 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sltiu r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5425 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLTIU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3295 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_sltiu (SD_, RS, RT, IMMEDIATE);
  }
#line 5453 "semantics.c"
  return nia;
  /* Extraction: SLTIU
       #undef do-not-use-icache
       6.0xb,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5462 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ANDI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ANDI_NORMAL
#undef ANDI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ANDI_NORMAL
#undef MY_NAME
#define MY_NAME "ANDI_NORMAL"

  /* Extraction: ANDI
       #define do-not-use-icache
       6.0xc,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5489 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xc,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 659 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "andi r%ld, r%ld, %#lx", \
                    (long) RT, \
                    (long) RS, \
                    (unsigned long) IMMEDIATE);
#line 5508 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ANDI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 673 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    TRACE_ALU_INPUT2 (GPR[RS], IMMEDIATE);
    GPR[RT] = GPR[RS] & IMMEDIATE;
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 5538 "semantics.c"
  return nia;
  /* Extraction: ANDI
       #undef do-not-use-icache
       6.0xc,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5547 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ORI_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ORI_NORMAL
#undef ORI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ORI_NORMAL
#undef MY_NAME
#define MY_NAME "ORI_NORMAL"

  /* Extraction: ORI
       #define do-not-use-icache
       6.0xd,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5574 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xd,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2799 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ori r%ld, r%ld, %#lx", \
                    (long) RT, \
                    (long) RS, \
                    (unsigned long) IMMEDIATE);
#line 5593 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ORI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2813 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_ori (SD_, RS, RT, IMMEDIATE);
  }
#line 5621 "semantics.c"
  return nia;
  /* Extraction: ORI
       #undef do-not-use-icache
       6.0xd,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5630 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_XORI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_XORI_NORMAL
#undef XORI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX XORI_NORMAL
#undef MY_NAME
#define MY_NAME "XORI_NORMAL"

  /* Extraction: XORI
       #define do-not-use-icache
       6.0xe,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5657 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xe,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3865 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "xori r%ld, r%ld, %#lx", \
                    (long) RT, \
                    (long) RS, \
                    (unsigned long) IMMEDIATE);
#line 5676 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_XORI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3879 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_xori (SD_, RS, RT, IMMEDIATE);
  }
#line 5704 "semantics.c"
  return nia;
  /* Extraction: XORI
       #undef do-not-use-icache
       6.0xe,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 5713 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LUI_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LUI_NORMAL
#undef LUI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LUI_NORMAL
#undef MY_NAME
#define MY_NAME "LUI_NORMAL"

  /* Extraction: LUI
       #define do-not-use-icache
       6.0xf,5.0x0,5.RT,16.IMMEDIATE */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5738 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xf,5.0x0,5.RT,16.IMMEDIATE */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2312 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lui r%ld, %#lx", \
                    (long) RT, \
                    (unsigned long) IMMEDIATE);
#line 5761 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LUI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2326 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    TRACE_ALU_INPUT1 (IMMEDIATE);
    GPR[RT] = EXTEND32 (IMMEDIATE << 16);
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 5791 "semantics.c"
  return nia;
  /* Extraction: LUI
       #undef do-not-use-icache
       6.0xf,5.0x0,5.RT,16.IMMEDIATE */

#undef RT
#undef IMMEDIATE
#line 5799 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_COPz_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_COPz_NORMAL
#undef COPz_NORMAL
#undef MY_PREFIX
#define MY_PREFIX COPz_NORMAL
#undef MY_NAME
#define MY_NAME "COPz_NORMAL"

  /* Extraction: COPz
       #define do-not-use-icache
       4.0x4,2.ZZ,5.COP_FUN0,5.COP_FUN1,16.COP_FUN2 */

#undef ZZ
#define ZZ ((unsigned) EXTRACTED32 (instruction_0, 27, 26)) /* cache - extraction */
#undef COP_FUN0
#define COP_FUN0 ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef COP_FUN1
#define COP_FUN1 ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef COP_FUN2
#define COP_FUN2 ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5828 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 4.0x4,2.ZZ,5.COP_FUN0,5.COP_FUN1,16.COP_FUN2 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5604 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cop%ld %ld%ld%ld", \
                    (long) ZZ, \
                    (long) COP_FUN0, \
                    (long) COP_FUN1, \
                    (long) COP_FUN2);
#line 5848 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_COPz_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5617 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    DecodeCoproc (instruction_0);
  }
#line 5876 "semantics.c"
  return nia;
  /* Extraction: COPz
       #undef do-not-use-icache
       4.0x4,2.ZZ,5.COP_FUN0,5.COP_FUN1,16.COP_FUN2 */

#undef ZZ
#undef COP_FUN0
#undef COP_FUN1
#undef COP_FUN2
#line 5886 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFC0_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFC0_COP0
#undef MFC0_COP0
#undef MY_PREFIX
#define MY_PREFIX MFC0_COP0
#undef MY_NAME
#define MY_NAME "MFC0_COP0"

  /* Extraction: MFC0
       #define do-not-use-icache
       6.0x10,5.0x0,5.RT,5.RD,5.0x0,6.REGX */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef REGX
#define REGX ((unsigned) MASKED32 (instruction_0, 5, 0)) /* cache - extraction */
#line 5913 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x0,5.RT,5.RD,5.0x0,6.REGX */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x026007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5550 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mfc0 r%ld, r%ld # %ld", \
                    (long) RT, \
                    (long) RD, \
                    (long) REGX);
#line 5937 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFC0_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5564 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    TRACE_ALU_INPUT0 ();
    DecodeCoproc (instruction_0);
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 5967 "semantics.c"
  return nia;
  /* Extraction: MFC0
       #undef do-not-use-icache
       6.0x10,5.0x0,5.RT,5.RD,5.0x0,6.REGX */

#undef RT
#undef RD
#undef REGX
#line 5976 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTC0_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTC0_COP0
#undef MTC0_COP0
#undef MY_PREFIX
#define MY_PREFIX MTC0_COP0
#undef MY_NAME
#define MY_NAME "MTC0_COP0"

  /* Extraction: MTC0
       #define do-not-use-icache
       6.0x10,5.0x4,5.RT,5.RD,5.0x0,6.REGX */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef REGX
#define REGX ((unsigned) MASKED32 (instruction_0, 5, 0)) /* cache - extraction */
#line 6003 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x4,5.RT,5.RD,5.0x0,6.REGX */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x026007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5570 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mtc0 r%ld, r%ld # %ld", \
                    (long) RT, \
                    (long) RD, \
                    (long) REGX);
#line 6027 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTC0_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5584 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    DecodeCoproc (instruction_0);
  }
#line 6055 "semantics.c"
  return nia;
  /* Extraction: MTC0
       #undef do-not-use-icache
       6.0x10,5.0x4,5.RT,5.RD,5.0x0,6.REGX */

#undef RT
#undef RD
#undef REGX
#line 6064 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0F_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0F_COP0
#undef BC0F_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0F_COP0
#undef MY_NAME
#define MY_NAME "BC0F_COP0"

  /* Extraction: BC0F
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x0,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6087 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x027c0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5405 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0f %ld", \
                    (long) OFFSET);
#line 6109 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0F_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5404 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5404:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6138 "semantics.c"
  return nia;
  /* Extraction: BC0F
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x0,16.OFFSET */

#undef OFFSET
#line 6145 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0T_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0T_COP0
#undef BC0T_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0T_COP0
#undef MY_NAME
#define MY_NAME "BC0T_COP0"

  /* Extraction: BC0T
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x1,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6168 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x1,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x027c0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5443 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0t %ld", \
                    (long) OFFSET);
#line 6190 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0T_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5442 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5442:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6219 "semantics.c"
  return nia;
  /* Extraction: BC0T
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x1,16.OFFSET */

#undef OFFSET
#line 6226 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0FL_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0FL_COP0
#undef BC0FL_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0FL_COP0
#undef MY_NAME
#define MY_NAME "BC0FL_COP0"

  /* Extraction: BC0FL
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x2,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6249 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x2,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x027c0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5428 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0fl %ld", \
                    (long) OFFSET);
#line 6271 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0FL_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5427 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5427:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6300 "semantics.c"
  return nia;
  /* Extraction: BC0FL
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x2,16.OFFSET */

#undef OFFSET
#line 6307 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0TL_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0TL_COP0
#undef BC0TL_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0TL_COP0
#undef MY_NAME
#define MY_NAME "BC0TL_COP0"

  /* Extraction: BC0TL
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x3,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6330 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x3,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x027c0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5457 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0tl %ld", \
                    (long) OFFSET);
#line 6352 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0TL_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5456 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5456:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6381 "semantics.c"
  return nia;
  /* Extraction: BC0TL
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x3,16.OFFSET */

#undef OFFSET
#line 6388 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBR_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBR_COP0
#undef TLBR_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBR_COP0
#undef MY_NAME
#define MY_NAME "TLBR_COP0"

  /* Extraction: TLBR
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x1 */

#line 6409 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x1 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5638 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbr");
#line 6430 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBR_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5637 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5637:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6459 "semantics.c"
  return nia;
  /* Extraction: TLBR
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x1 */

#line 6465 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBWI_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBWI_COP0
#undef TLBWI_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBWI_COP0
#undef MY_NAME
#define MY_NAME "TLBWI_COP0"

  /* Extraction: TLBWI
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x2 */

#line 6486 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x2 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5653 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbwi");
#line 6507 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBWI_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5652 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5652:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6536 "semantics.c"
  return nia;
  /* Extraction: TLBWI
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x2 */

#line 6542 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBWR_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBWR_COP0
#undef TLBWR_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBWR_COP0
#undef MY_NAME
#define MY_NAME "TLBWR_COP0"

  /* Extraction: TLBWR
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x6 */

#line 6563 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x6 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5668 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbwr");
#line 6584 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBWR_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5667 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5667:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6613 "semantics.c"
  return nia;
  /* Extraction: TLBWR
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x6 */

#line 6619 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBP_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBP_COP0
#undef TLBP_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBP_COP0
#undef MY_NAME
#define MY_NAME "TLBP_COP0"

  /* Extraction: TLBP
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x8 */

#line 6640 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5623 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbp");
#line 6661 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBP_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5622 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5622:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 6690 "semantics.c"
  return nia;
  /* Extraction: TLBP
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x8 */

#line 6696 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_RFE_COP0 (SIM_DESC sd,
                   instruction_word instruction_0,
                   instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RFE_COP0
#undef RFE_COP0
#undef MY_PREFIX
#define MY_PREFIX RFE_COP0
#undef MY_NAME
#define MY_NAME "RFE_COP0"

  /* Extraction: RFE
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x10 */

#line 6717 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x10 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5589 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "rfe");
#line 6738 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RFE_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5599 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    DecodeCoproc (instruction_0);
  }
#line 6766 "semantics.c"
  return nia;
  /* Extraction: RFE
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x10 */

#line 6772 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ERET_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ERET_COP0
#undef ERET_COP0
#undef MY_PREFIX
#define MY_PREFIX ERET_COP0
#undef MY_NAME
#define MY_NAME "ERET_COP0"

  /* Extraction: ERET
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x18 */

#line 6793 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x18 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5523 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "eret");
#line 6814 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ERET_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5534 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    if (SR & status_ERL)
      {
        /* Oops, not yet available */
        sim_io_printf (SD, "Warning: ERET when SR[ERL] set not supported");
        NIA = EPC;
        SR &= ~status_ERL;
      }
    else
      {
        NIA = EPC;
        SR &= ~status_EXL;
      }
  }
#line 6853 "semantics.c"
  return nia;
  /* Extraction: ERET
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x18 */

#line 6859 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFC1b_COP1
#undef MFC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX MFC1b_COP1
#undef MY_NAME
#define MY_NAME "MFC1b_COP1"

  /* Extraction: MFC1b
       #define do-not-use-icache
       6.0x11,5.0x0,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 6886 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x0,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4770 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mfc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 6923 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4781 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    check_fpu (SD_);
    GPR[RT] = EXTEND32 (FGR[FS]);
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 6953 "semantics.c"
  return nia;
  /* Extraction: MFC1b
       #undef do-not-use-icache
       6.0x11,5.0x0,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#line 6962 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CFC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CFC1b_COP1
#undef CFC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX CFC1b_COP1
#undef MY_NAME
#define MY_NAME "CFC1b_COP1"

  /* Extraction: CFC1b
       #define do-not-use-icache
       6.0x11,5.0x2,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 6989 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x2,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4293 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cfc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 7026 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CFC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4299 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    check_fpu (SD_);
    if (FS == 0 || FS == 31)
      {
        unsigned_word  fcr = ValueFCR (FS);
        TRACE_ALU_INPUT1 (fcr);
        GPR[RT] = fcr;
      }
    /* else NOP */
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 7062 "semantics.c"
  return nia;
  /* Extraction: CFC1b
       #undef do-not-use-icache
       6.0x11,5.0x2,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#line 7071 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTC1b_COP1
#undef MTC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX MTC1b_COP1
#undef MY_NAME
#define MY_NAME "MTC1b_COP1"

  /* Extraction: MTC1b
       #define do-not-use-icache
       6.0x11,5.0x4,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 7098 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x4,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4935 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mtc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 7135 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4946 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    check_fpu (SD_); 
    StoreFPR (FS, fmt_uninterpreted_32, VL4_8 (GPR[RT]));
  }
#line 7164 "semantics.c"
  return nia;
  /* Extraction: MTC1b
       #undef do-not-use-icache
       6.0x11,5.0x4,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#line 7173 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CTC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CTC1b_COP1
#undef CTC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX CTC1b_COP1
#undef MY_NAME
#define MY_NAME "CTC1b_COP1"

  /* Extraction: CTC1b
       #define do-not-use-icache
       6.0x11,5.0x6,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 7200 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x6,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4342 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ctc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 7237 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CTC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4348 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    check_fpu (SD_);
    TRACE_ALU_INPUT1 (GPR[RT]);
    if (FS == 31)
      StoreFCR (FS, GPR[RT]);
    /* else NOP */
  }
#line 7269 "semantics.c"
  return nia;
  /* Extraction: CTC1b
       #undef do-not-use-icache
       6.0x11,5.0x6,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#line 7278 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC1b_COP1S (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC1b_COP1S
#undef BC1b_COP1S
#undef MY_PREFIX
#define MY_PREFIX BC1b_COP1S
#undef MY_NAME
#define MY_NAME "BC1b_COP1S"

  /* Extraction: BC1b
       #define do-not-use-icache
       6.0x11,5.0x8,3.CC,1.ND,1.TF,16.OFFSET */

#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 20, 18)) /* cache - extraction */
#undef ND
#define ND ((unsigned) EXTRACTED32 (instruction_0, 17, 17)) /* cache - extraction */
#undef TF
#define TF ((unsigned) EXTRACTED32 (instruction_0, 16, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 7307 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x8,3.CC,1.ND,1.TF,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x01000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (CC == 0)
#line 4181 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "bc1%s%s %ld", \
                      str_TF (SD_, TF), \
                      str_ND (SD_, ND), \
                      (long) OFFSET);
#line 7346 "semantics.c"
      else
#line 4182 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "bc1%s%s %ld, %ld", \
                      str_TF (SD_, TF), \
                      str_ND (SD_, ND), \
                      (long) CC, \
                      (long) OFFSET);
#line 7357 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC1b_COP1S, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4193 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    check_fpu (SD_);
    if (GETFCC(CC) == TF)
      {
        address_word dest = NIA + (EXTEND16 (OFFSET) << 2);
        DELAY_SLOT (dest);
      }
    else if (ND)
      {
        NULLIFY_NEXT_INSTRUCTION ();
      }
  }
#line 7394 "semantics.c"
  return nia;
  /* Extraction: BC1b
       #undef do-not-use-icache
       6.0x11,5.0x8,3.CC,1.ND,1.TF,16.OFFSET */

#undef CC
#undef ND
#undef TF
#undef OFFSET
#line 7404 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADD_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADD_fmt_COP1
#undef ADD_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ADD_fmt_COP1
#undef MY_NAME
#define MY_NAME "ADD_fmt_COP1"

  /* Extraction: ADD.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x0 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 7435 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x0 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4101 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "add.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 7469 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADD_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4115 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, Add (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
  }
#line 7500 "semantics.c"
  return nia;
  /* Extraction: ADD.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x0 */

#undef FMT
#undef FT
#undef FS
#undef FD
#undef SFRAME
#line 7511 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SUB_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SUB_fmt_COP1
#undef SUB_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX SUB_fmt_COP1
#undef MY_NAME
#define MY_NAME "SUB_fmt_COP1"

  /* Extraction: SUB.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x1 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 7542 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x1 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5249 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sub.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 7576 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SUB_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5263 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, Sub (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
  }
#line 7607 "semantics.c"
  return nia;
  /* Extraction: SUB.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x1 */

#undef FMT
#undef FT
#undef FS
#undef FD
#undef SFRAME
#line 7618 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MUL_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MUL_fmt_COP1
#undef MUL_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MUL_fmt_COP1
#undef MY_NAME
#define MY_NAME "MUL_fmt_COP1"

  /* Extraction: MUL.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x2 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 7649 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x2 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4952 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mul.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 7683 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MUL_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4966 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, Multiply (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
  }
#line 7714 "semantics.c"
  return nia;
  /* Extraction: MUL.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x2 */

#undef FMT
#undef FT
#undef FS
#undef FD
#undef SFRAME
#line 7725 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DIV_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DIV_fmt_COP1
#undef DIV_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX DIV_fmt_COP1
#undef MY_NAME
#define MY_NAME "DIV_fmt_COP1"

  /* Extraction: DIV.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x3 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 7756 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x3 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4507 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "div.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 7790 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DIV_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4521 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt, Divide (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
  }
#line 7820 "semantics.c"
  return nia;
  /* Extraction: DIV.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,5.FD,6.0x3 */

#undef FMT
#undef FT
#undef FS
#undef FD
#undef SFRAME
#line 7831 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVZ_fmt_COP1 (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVZ_fmt_COP1
#undef MOVZ_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOVZ_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOVZ_fmt_COP1"

  /* Extraction: MOVZ.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x12 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 7862 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x12 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4886 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movz.%s f%ld, f%ld, r%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) RT);
#line 7896 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVZ_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4895 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    check_fpu (SD_);
    if (GPR[RT] == 0)
      StoreFPR (FD, FMT, ValueFPR (FS, FMT));
    else
      StoreFPR (FD, FMT, ValueFPR (FD, FMT));
  }
#line 7928 "semantics.c"
  return nia;
  /* Extraction: MOVZ.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x12 */

#undef FMT
#undef RT
#undef FS
#undef FD
#undef SFRAME
#line 7939 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVN_fmt_COP1 (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVN_fmt_COP1
#undef MOVN_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOVN_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOVN_fmt_COP1"

  /* Extraction: MOVN.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x13 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 7970 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x13 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4861 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movn.%s f%ld, f%ld, r%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) RT);
#line 8004 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVN_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4870 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    check_fpu (SD_);
    if (GPR[RT] != 0)
      StoreFPR (FD, FMT, ValueFPR (FS, FMT));
    else
      StoreFPR (FD, FMT, ValueFPR (FD, FMT));
  }
#line 8036 "semantics.c"
  return nia;
  /* Extraction: MOVN.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.RT,5.FS,5.FD,6.0x13 */

#undef FMT
#undef RT
#undef FS
#undef FD
#undef SFRAME
#line 8047 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_C_cond_fmtb_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_C_cond_fmtb_COP1
#undef C_cond_fmtb_COP1
#undef MY_PREFIX
#define MY_PREFIX C_cond_fmtb_COP1
#undef MY_NAME
#define MY_NAME "C_cond_fmtb_COP1"

  /* Extraction: C.cond.fmtb
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,3.CC,2.0x0,2.0x3,4.COND */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 10, 8)) /* cache - extraction */
#undef COND
#define COND ((unsigned) MASKED32 (instruction_0, 3, 0)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8080 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.FT,5.FS,3.CC,2.0x0,2.0x3,4.COND */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000000c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (CC == 0)
#line 4219 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "c.%s.%s f%ld, f%ld", \
                      str_COND (SD_, COND), \
                      str_FMT (SD_, FMT), \
                      (long) FS, \
                      (long) FT);
#line 8120 "semantics.c"
      else
#line 4220 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "c.%s.%s %ld, f%ld, f%ld", \
                      str_COND (SD_, COND), \
                      str_FMT (SD_, FMT), \
                      (long) CC, \
                      (long) FS, \
                      (long) FT);
#line 8132 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_C_cond_fmtb_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4231 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    Compare (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt, COND, CC);
    TRACE_ALU_RESULT (ValueFCR (31));
  }
#line 8164 "semantics.c"
  return nia;
  /* Extraction: C.cond.fmtb
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.FT,5.FS,3.CC,2.0x0,2.0x3,4.COND */

#undef FMT
#undef FT
#undef FS
#undef CC
#undef COND
#undef SFRAME
#line 8176 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVtf_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVtf_fmt_COP1
#undef MOVtf_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOVtf_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOVtf_fmt_COP1"

  /* Extraction: MOVtf.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,3.CC,1.0x0,1.TF,5.FS,5.FD,6.0x11 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 20, 18)) /* cache - extraction */
#undef TF
#define TF ((unsigned) EXTRACTED32 (instruction_0, 16, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8209 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,3.CC,1.0x0,1.TF,5.FS,5.FD,6.0x11 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x00020000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4830 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mov%s.%s f%ld, f%ld, %ld", \
                    str_TF (SD_, TF), \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) CC);
#line 8249 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVtf_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4839 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if (fmt != fmt_ps)
      {
        if (GETFCC(CC) == TF)
    	StoreFPR (FD, fmt, ValueFPR (FS, fmt));
        else
    	StoreFPR (FD, fmt, ValueFPR (FD, fmt));   /* set fmt */
      }
    else
      {
        unsigned64 fd;
        fd = PackPS (PSUpper (ValueFPR ((GETFCC (CC+1) == TF) ? FS : FD,
    				      fmt_ps)),
    		   PSLower (ValueFPR ((GETFCC (CC+0) == TF) ? FS : FD,
    				      fmt_ps)));
        StoreFPR (FD, fmt_ps, fd);
      }
  }
#line 8294 "semantics.c"
  return nia;
  /* Extraction: MOVtf.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,3.CC,1.0x0,1.TF,5.FS,5.FD,6.0x11 */

#undef FMT
#undef CC
#undef TF
#undef FS
#undef FD
#undef SFRAME
#line 8306 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SQRT_fmt_COP1 (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SQRT_fmt_COP1
#undef SQRT_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX SQRT_fmt_COP1
#undef MY_NAME
#define MY_NAME "SQRT_fmt_COP1"

  /* Extraction: SQRT.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x4 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8335 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x4 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5229 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sqrt.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8373 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SQRT_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5242 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt,  (SquareRoot (ValueFPR (FS, fmt), fmt)));
  }
#line 8403 "semantics.c"
  return nia;
  /* Extraction: SQRT.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x4 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 8413 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ABS_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ABS_fmt_COP1
#undef ABS_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ABS_fmt_COP1
#undef MY_NAME
#define MY_NAME "ABS_fmt_COP1"

  /* Extraction: ABS.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x5 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8442 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x5 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4078 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "abs.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8480 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ABS_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4092 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, AbsoluteValue (ValueFPR (FS, fmt), fmt));
  }
#line 8511 "semantics.c"
  return nia;
  /* Extraction: ABS.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x5 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 8521 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOV_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOV_fmt_COP1
#undef MOV_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOV_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOV_fmt_COP1"

  /* Extraction: MOV.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x6 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8550 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x6 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4788 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mov.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8588 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOV_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4802 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, ValueFPR (FS, fmt));
  }
#line 8619 "semantics.c"
  return nia;
  /* Extraction: MOV.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x6 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 8629 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_NEG_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_NEG_fmt_COP1
#undef NEG_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX NEG_fmt_COP1
#undef MY_NAME
#define MY_NAME "NEG_fmt_COP1"

  /* Extraction: NEG.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x7 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8658 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x7 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4974 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "neg.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8696 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_NEG_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4988 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, Negate (ValueFPR (FS, fmt), fmt));
  }
#line 8727 "semantics.c"
  return nia;
  /* Extraction: NEG.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x7 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 8737 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ROUND_W_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ROUND_W_fmt_COP1
#undef ROUND_W_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ROUND_W_fmt_COP1
#undef MY_NAME
#define MY_NAME "ROUND_W_fmt_COP1"

  /* Extraction: ROUND.W.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xc */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8766 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xc */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5134 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "round.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8804 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ROUND_W_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5147 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_word, Convert (FP_RM_NEAREST, ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 8835 "semantics.c"
  return nia;
  /* Extraction: ROUND.W.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xc */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 8845 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TRUNC_W_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TRUNC_W_COP1
#undef TRUNC_W_COP1
#undef MY_PREFIX
#define MY_PREFIX TRUNC_W_COP1
#undef MY_NAME
#define MY_NAME "TRUNC_W_COP1"

  /* Extraction: TRUNC.W
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xd */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8874 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xd */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5377 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "trunc.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 8912 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TRUNC_W_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5390 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_word, Convert (FP_RM_TOZERO, ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 8943 "semantics.c"
  return nia;
  /* Extraction: TRUNC.W
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xd */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 8953 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CEIL_W_COP1 (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CEIL_W_COP1
#undef CEIL_W_COP1
#undef MY_PREFIX
#define MY_PREFIX CEIL_W_COP1
#undef MY_NAME
#define MY_NAME "CEIL_W_COP1"

  /* Extraction: CEIL.W
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xe */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8982 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xe */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4258 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ceil.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9020 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CEIL_W_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4271 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_word, Convert (FP_RM_TOPINF, ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 9051 "semantics.c"
  return nia;
  /* Extraction: CEIL.W
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xe */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9061 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_FLOOR_W_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_FLOOR_W_fmt_COP1
#undef FLOOR_W_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX FLOOR_W_fmt_COP1
#undef MY_NAME
#define MY_NAME "FLOOR_W_fmt_COP1"

  /* Extraction: FLOOR.W.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xf */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9090 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xf */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4625 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "floor.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9128 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_FLOOR_W_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4638 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_word, Convert (FP_RM_TOMINF, ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 9159 "semantics.c"
  return nia;
  /* Extraction: FLOOR.W.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0xf */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9169 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_RECIP_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RECIP_fmt_COP1
#undef RECIP_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX RECIP_fmt_COP1
#undef MY_NAME
#define MY_NAME "RECIP_fmt_COP1"

  /* Extraction: RECIP.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x15 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9198 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x15 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5102 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "recip.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9236 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RECIP_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5109 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt, Recip (ValueFPR (FS, fmt), fmt));
  }
#line 9266 "semantics.c"
  return nia;
  /* Extraction: RECIP.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x15 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9276 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_RSQRT_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RSQRT_fmt_COP1
#undef RSQRT_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX RSQRT_fmt_COP1
#undef MY_NAME
#define MY_NAME "RSQRT_fmt_COP1"

  /* Extraction: RSQRT.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x16 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9305 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x16 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5155 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "rsqrt.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9343 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RSQRT_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5162 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt, RSquareRoot (ValueFPR (FS, fmt), fmt));
  }
#line 9373 "semantics.c"
  return nia;
  /* Extraction: RSQRT.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x16 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9383 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_S_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_S_fmt_COP1
#undef CVT_S_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_S_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_S_fmt_COP1"

  /* Extraction: CVT.S.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x20 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9412 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x20 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4435 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.s.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9450 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_S_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4449 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if ((fmt == fmt_single) | 0)
      SignalException (ReservedInstruction, instruction_0);
    StoreFPR (FD, fmt_single, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
    	    fmt_single));
  }
#line 9483 "semantics.c"
  return nia;
  /* Extraction: CVT.S.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x20 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9493 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_D_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_D_fmt_COP1
#undef CVT_D_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_D_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_D_fmt_COP1"

  /* Extraction: CVT.D.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x21 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9522 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x21 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4375 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.d.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9560 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_D_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4389 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if ((fmt == fmt_double) | 0)
      SignalException (ReservedInstruction, instruction_0);
    StoreFPR (FD, fmt_double, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
    	    fmt_double));
  }
#line 9593 "semantics.c"
  return nia;
  /* Extraction: CVT.D.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x21 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9603 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_W_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_W_fmt_COP1
#undef CVT_W_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_W_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_W_fmt_COP1"

  /* Extraction: CVT.W.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x24 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9632 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x24 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4483 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9670 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_W_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4497 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if ((fmt == fmt_word) | ((fmt == fmt_long) || (fmt == fmt_word)))
      SignalException (ReservedInstruction, instruction_0);
    StoreFPR (FD, fmt_word, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 9703 "semantics.c"
  return nia;
  /* Extraction: CVT.W.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT,5.0x0,5.FS,5.FD,6.0x24 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9713 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWXC1_COP1X (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWXC1_COP1X
#undef SWXC1_COP1X
#undef MY_PREFIX
#define MY_PREFIX SWXC1_COP1X
#undef MY_NAME
#define MY_NAME "SWXC1_COP1X"

  /* Extraction: SWXC1
       #define do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.FS,5.0x0,6.0x8 */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef INDEX
#define INDEX ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9742 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.BASE,5.INDEX,5.FS,5.0x0,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007ff) != 0x00000008)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5318 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swxc1 f%ld, r%ld(r%ld)", \
                    (long) FS, \
                    (long) INDEX, \
                    (long) BASE);
#line 9780 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWXC1_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5325 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"

    address_word base = GPR[BASE];
    address_word index = GPR[INDEX];
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    {
     address_word vaddr = loadstore_ea (SD_, base, index);
     address_word paddr;
     int uncached;
     if ((vaddr & 3) != 0)
       {
         SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, write_transfer, sim_core_unaligned_signal);
       }
     else
     {
      if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
      {
       unsigned64 memval = 0;
       unsigned64 memval1 = 0;
       unsigned64 mask = 0x7;
       unsigned int byte;
       paddr = ((paddr & ~mask) | ((paddr & mask) ^ (ReverseEndian << 2)));
       byte = ((vaddr & mask) ^ (BigEndianCPU << 2));
       memval = (((unsigned64)COP_SW(1,FS)) << (8 * byte));
        {
         StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
        }
      }
     }
    }
  }
#line 9837 "semantics.c"
  return nia;
  /* Extraction: SWXC1
       #undef do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.FS,5.0x0,6.0x8 */

#undef BASE
#undef INDEX
#undef FS
#undef SFRAME
#line 9847 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BEQL_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BEQL_NORMAL
#undef BEQL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BEQL_NORMAL
#undef MY_NAME
#define MY_NAME "BEQL_NORMAL"

  /* Extraction: BEQL
       #define do-not-use-icache
       6.0x14,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 9874 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x14,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 705 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "beql r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 9893 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BEQL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 718 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 9927 "semantics.c"
  return nia;
  /* Extraction: BEQL
       #undef do-not-use-icache
       6.0x14,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#line 9936 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BNEL_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BNEL_NORMAL
#undef BNEL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BNEL_NORMAL
#undef MY_NAME
#define MY_NAME "BNEL_NORMAL"

  /* Extraction: BNEL
       #define do-not-use-icache
       6.0x15,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 9963 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x15,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1070 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bnel r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 9982 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BNEL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1083 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 10016 "semantics.c"
  return nia;
  /* Extraction: BNEL
       #undef do-not-use-icache
       6.0x15,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#line 10025 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLEZL_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLEZL_NORMAL
#undef BLEZL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BLEZL_NORMAL
#undef MY_NAME
#define MY_NAME "BLEZL_NORMAL"

  /* Extraction: BLEZL
       #define do-not-use-icache
       6.0x16,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10050 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x16,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 913 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 10073 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLEZL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 926 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] <= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 10107 "semantics.c"
  return nia;
  /* Extraction: BLEZL
       #undef do-not-use-icache
       6.0x16,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 10115 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGTZL_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGTZL_NORMAL
#undef BGTZL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BGTZL_NORMAL
#undef MY_NAME
#define MY_NAME "BGTZL_NORMAL"

  /* Extraction: BGTZL
       #define do-not-use-icache
       6.0x17,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10140 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x17,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 860 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgtzl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 10163 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGTZL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 873 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] > 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 10199 "semantics.c"
  return nia;
  /* Extraction: BGTZL
       #undef do-not-use-icache
       6.0x17,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 10207 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LB_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LB_NORMAL
#undef LB_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LB_NORMAL
#undef MY_NAME
#define MY_NAME "LB_NORMAL"

  /* Extraction: LB
       #define do-not-use-icache
       6.0x20,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10234 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x20,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2090 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lb r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10253 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LB_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2104 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    GPR[RT] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 10281 "semantics.c"
  return nia;
  /* Extraction: LB
       #undef do-not-use-icache
       6.0x20,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10290 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LH_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LH_NORMAL
#undef LH_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LH_NORMAL
#undef MY_NAME
#define MY_NAME "LH_NORMAL"

  /* Extraction: LH
       #define do-not-use-icache
       6.0x21,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10317 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x21,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2193 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lh r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10336 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LH_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2207 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    GPR[RT] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 10364 "semantics.c"
  return nia;
  /* Extraction: LH
       #undef do-not-use-icache
       6.0x21,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10373 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWL_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWL_NORMAL
#undef LWL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LWL_NORMAL
#undef MY_NAME
#define MY_NAME "LWL_NORMAL"

  /* Extraction: LWL
       #define do-not-use-icache
       6.0x22,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10400 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x22,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2371 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwl r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10419 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2385 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    GPR[RT] = EXTEND32 (do_load_left (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]));
  }
#line 10447 "semantics.c"
  return nia;
  /* Extraction: LWL
       #undef do-not-use-icache
       6.0x22,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10456 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LW_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LW_NORMAL
#undef LW_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LW_NORMAL
#undef MY_NAME
#define MY_NAME "LW_NORMAL"

  /* Extraction: LW
       #define do-not-use-icache
       6.0x23,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10483 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x23,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2333 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lw r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10502 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LW_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2347 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    GPR[RT] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 10530 "semantics.c"
  return nia;
  /* Extraction: LW
       #undef do-not-use-icache
       6.0x23,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10539 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LBU_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LBU_NORMAL
#undef LBU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LBU_NORMAL
#undef MY_NAME
#define MY_NAME "LBU_NORMAL"

  /* Extraction: LBU
       #define do-not-use-icache
       6.0x24,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10566 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x24,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2109 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lbu r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10585 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LBU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2123 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    GPR[RT] = do_load (SD_, AccessLength_BYTE, GPR[BASE], EXTEND16 (OFFSET));
  }
#line 10613 "semantics.c"
  return nia;
  /* Extraction: LBU
       #undef do-not-use-icache
       6.0x24,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10622 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LHU_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LHU_NORMAL
#undef LHU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LHU_NORMAL
#undef MY_NAME
#define MY_NAME "LHU_NORMAL"

  /* Extraction: LHU
       #define do-not-use-icache
       6.0x25,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10649 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x25,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2212 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lhu r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10668 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LHU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2226 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    GPR[RT] = do_load (SD_, AccessLength_HALFWORD, GPR[BASE], EXTEND16 (OFFSET));
  }
#line 10696 "semantics.c"
  return nia;
  /* Extraction: LHU
       #undef do-not-use-icache
       6.0x25,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10705 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWR_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWR_NORMAL
#undef LWR_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LWR_NORMAL
#undef MY_NAME
#define MY_NAME "LWR_NORMAL"

  /* Extraction: LWR
       #define do-not-use-icache
       6.0x26,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10732 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x26,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2390 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwr r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10751 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWR_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2404 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    GPR[RT] = EXTEND32 (do_load_right (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]));
  }
#line 10779 "semantics.c"
  return nia;
  /* Extraction: LWR
       #undef do-not-use-icache
       6.0x26,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10788 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SB_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SB_NORMAL
#undef SB_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SB_NORMAL
#undef MY_NAME
#define MY_NAME "SB_NORMAL"

  /* Extraction: SB
       #define do-not-use-icache
       6.0x28,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10815 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x28,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2966 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sb r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10834 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SB_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2980 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_store (SD_, AccessLength_BYTE, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 10862 "semantics.c"
  return nia;
  /* Extraction: SB
       #undef do-not-use-icache
       6.0x28,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10871 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SH_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SH_NORMAL
#undef SH_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SH_NORMAL
#undef MY_NAME
#define MY_NAME "SH_NORMAL"

  /* Extraction: SH
       #define do-not-use-icache
       6.0x29,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10898 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x29,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3133 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sh r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 10917 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SH_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3147 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_store (SD_, AccessLength_HALFWORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 10945 "semantics.c"
  return nia;
  /* Extraction: SH
       #undef do-not-use-icache
       6.0x29,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 10954 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWL_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWL_NORMAL
#undef SWL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SWL_NORMAL
#undef MY_NAME
#define MY_NAME "SWL_NORMAL"

  /* Extraction: SWL
       #define do-not-use-icache
       6.0x2a,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 10981 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2a,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3540 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swl r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11000 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3554 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_store_left (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 11028 "semantics.c"
  return nia;
  /* Extraction: SWL
       #undef do-not-use-icache
       6.0x2a,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 11037 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SW_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SW_NORMAL
#undef SW_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SW_NORMAL
#undef MY_NAME
#define MY_NAME "SW_NORMAL"

  /* Extraction: SW
       #define do-not-use-icache
       6.0x2b,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11064 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2b,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3502 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sw r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11083 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SW_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3516 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_store (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 11111 "semantics.c"
  return nia;
  /* Extraction: SW
       #undef do-not-use-icache
       6.0x2b,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 11120 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWR_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWR_NORMAL
#undef SWR_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SWR_NORMAL
#undef MY_NAME
#define MY_NAME "SWR_NORMAL"

  /* Extraction: SWR
       #define do-not-use-icache
       6.0x2e,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11147 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2e,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3559 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swr r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11166 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWR_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3573 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_store_right (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 11194 "semantics.c"
  return nia;
  /* Extraction: SWR
       #undef do-not-use-icache
       6.0x2e,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 11203 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CACHE_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CACHE_NORMAL
#undef CACHE_NORMAL
#undef MY_PREFIX
#define MY_PREFIX CACHE_NORMAL
#undef MY_NAME
#define MY_NAME "CACHE_NORMAL"

  /* Extraction: CACHE
       #define do-not-use-icache
       6.0x2f,5.BASE,5.OP,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OP
#define OP ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11230 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2f,5.BASE,5.OP,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5472 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cache %ld, %ld(r%ld)", \
                    (long) OP, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11249 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CACHE_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5484 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
        CacheOp(OP,vaddr,paddr,instruction_0);
    }
  }
#line 11285 "semantics.c"
  return nia;
  /* Extraction: CACHE
       #undef do-not-use-icache
       6.0x2f,5.BASE,5.OP,16.OFFSET */

#undef BASE
#undef OP
#undef OFFSET
#line 11294 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWCz_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWCz_NORMAL
#undef LWCz_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LWCz_NORMAL
#undef MY_NAME
#define MY_NAME "LWCz_NORMAL"

  /* Extraction: LWCz
       #define do-not-use-icache
       4.0xc,2.ZZ,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#define ZZ ((unsigned) EXTRACTED32 (instruction_0, 27, 26)) /* cache - extraction */
#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11323 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 4.0xc,2.ZZ,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2352 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwc%ld r%ld, %ld(r%ld)", \
                    (long) ZZ, \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11343 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWCz_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2366 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    COP_LW (ZZ, RT, do_load (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 11371 "semantics.c"
  return nia;
  /* Extraction: LWCz
       #undef do-not-use-icache
       4.0xc,2.ZZ,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#undef BASE
#undef RT
#undef OFFSET
#line 11381 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LL_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LL_NORMAL
#undef LL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LL_NORMAL
#undef MY_NAME
#define MY_NAME "LL_NORMAL"

  /* Extraction: LL
       #define do-not-use-icache
       6.0x30,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11408 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x30,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2231 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ll r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11427 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2243 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if ((vaddr & 3) != 0)
        {
          SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, read_transfer, sim_core_unaligned_signal);
        }
      else
        {
    	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
    	  {
    	    unsigned64 memval = 0;
    	    unsigned64 memval1 = 0;
    	    unsigned64 mask = 0x7;
    	    unsigned int shift = 2;
    	    unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);
    	    unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);
    	    unsigned int byte;
    	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
    	    LoadMemory(&memval,&memval1,uncached,AccessLength_WORD,paddr,vaddr,isDATA,isREAL);
    	    byte = ((vaddr & mask) ^ (bigend << shift));
    	    GPR[RT] = EXTEND32 (memval >> (8 * byte));
    	    LLBIT = 1;
    	  }
        }
    }
  }
#line 11483 "semantics.c"
  return nia;
  /* Extraction: LL
       #undef do-not-use-icache
       6.0x30,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 11492 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWC1_COP1 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWC1_COP1
#undef LWC1_COP1
#undef MY_PREFIX
#define MY_PREFIX LWC1_COP1
#undef MY_NAME
#define MY_NAME "LWC1_COP1"

  /* Extraction: LWC1
       #define do-not-use-icache
       6.0x31,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11519 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x31,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4705 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11552 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWC1_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4719 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    check_fpu (SD_);
    COP_LW (1, FT, do_load (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 11581 "semantics.c"
  return nia;
  /* Extraction: LWC1
       #undef do-not-use-icache
       6.0x31,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#line 11590 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_PREF_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_PREF_NORMAL
#undef PREF_NORMAL
#undef MY_PREFIX
#define MY_PREFIX PREF_NORMAL
#undef MY_NAME
#define MY_NAME "PREF_NORMAL"

  /* Extraction: PREF
       #define do-not-use-icache
       6.0x33,5.BASE,5.HINT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef HINT
#define HINT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11617 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x33,5.BASE,5.HINT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2818 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "pref %ld, %ld(r%ld)", \
                    (long) HINT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11636 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_PREF_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2827 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      {
        if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
    	Prefetch(uncached,paddr,vaddr,isDATA,HINT);
      }
    }
  }
#line 11674 "semantics.c"
  return nia;
  /* Extraction: PREF
       #undef do-not-use-icache
       6.0x33,5.BASE,5.HINT,16.OFFSET */

#undef BASE
#undef HINT
#undef OFFSET
#line 11683 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LDC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LDC1b_COP1
#undef LDC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX LDC1b_COP1
#undef MY_NAME
#define MY_NAME "LDC1b_COP1"

  /* Extraction: LDC1b
       #define do-not-use-icache
       6.0x35,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11710 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x35,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4657 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ldc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11743 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LDC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4667 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    check_fpu (SD_);
    COP_LD (1, FT, do_load (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 11772 "semantics.c"
  return nia;
  /* Extraction: LDC1b
       #undef do-not-use-icache
       6.0x35,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#line 11781 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWCz_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWCz_NORMAL
#undef SWCz_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SWCz_NORMAL
#undef MY_NAME
#define MY_NAME "SWCz_NORMAL"

  /* Extraction: SWCz
       #define do-not-use-icache
       4.0xe,2.ZZ,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#define ZZ ((unsigned) EXTRACTED32 (instruction_0, 27, 26)) /* cache - extraction */
#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11810 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 4.0xe,2.ZZ,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3521 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swc%ld r%ld, %ld(r%ld)", \
                    (long) ZZ, \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11830 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWCz_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3535 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    do_store (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), COP_SW (ZZ, RT));
  }
#line 11858 "semantics.c"
  return nia;
  /* Extraction: SWCz
       #undef do-not-use-icache
       4.0xe,2.ZZ,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#undef BASE
#undef RT
#undef OFFSET
#line 11868 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SC_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SC_NORMAL
#undef SC_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SC_NORMAL
#undef MY_NAME
#define MY_NAME "SC_NORMAL"

  /* Extraction: SC
       #define do-not-use-icache
       6.0x38,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 11895 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x38,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2985 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sc r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 11914 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SC_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2997 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    unsigned32 instruction = instruction_0;
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if ((vaddr & 3) != 0)
        {
    	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, write_transfer, sim_core_unaligned_signal);
        }
      else
        {
    	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
    	  {
    	    unsigned64 memval = 0;
    	    unsigned64 memval1 = 0;
    	    unsigned64 mask = 0x7;
    	    unsigned int byte;
    	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (ReverseEndian << 2)));
    	    byte = ((vaddr & mask) ^ (BigEndianCPU << 2));
    	    memval = ((unsigned64) GPR[RT] << (8 * byte));
    	    if (LLBIT)
    	      {
    		StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
    	      }
    	    GPR[RT] = LLBIT;
    	  }
        }
    }
  }
#line 11971 "semantics.c"
  return nia;
  /* Extraction: SC
       #undef do-not-use-icache
       6.0x38,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 11980 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWC1_COP1 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWC1_COP1
#undef SWC1_COP1
#undef MY_PREFIX
#define MY_PREFIX SWC1_COP1
#undef MY_NAME
#define MY_NAME "SWC1_COP1"

  /* Extraction: SWC1
       #define do-not-use-icache
       6.0x39,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 12007 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x39,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5272 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12040 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWC1_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5286 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    check_fpu (SD_);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if ((vaddr & 3) != 0)
        {
    	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, AccessLength_WORD+1, vaddr, write_transfer, sim_core_unaligned_signal);
        }
      else
        {
    	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
    	  {
    	    uword64 memval = 0;
    	    uword64 memval1 = 0;
    	    uword64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
    	    address_word reverseendian = (ReverseEndian ?(mask ^ AccessLength_WORD): 0);
    	    address_word bigendiancpu = (BigEndianCPU ?(mask ^ AccessLength_WORD): 0);
    	    unsigned int byte;
    	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
    	    byte = ((vaddr & mask) ^ bigendiancpu);
    	    memval = (((uword64)COP_SW(((instruction_0 >> 26) & 0x3),FT)) << (8 * byte));
    	    StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
    	  }
        }
    }
  }
#line 12095 "semantics.c"
  return nia;
  /* Extraction: SWC1
       #undef do-not-use-icache
       6.0x39,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#line 12104 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SDC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SDC1b_COP1
#undef SDC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX SDC1b_COP1
#undef MY_NAME
#define MY_NAME "SDC1b_COP1"

  /* Extraction: SDC1b
       #define do-not-use-icache
       6.0x3d,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 12131 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x3d,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5180 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sdc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12164 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SDC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5190 "/home/blakedonzac/cs161/cs161-gdb-1.5/./gdb-6.6+cs161/sim/mips/mips.igen"
    check_fpu (SD_);
    do_store (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), COP_SD (1, FT));
  }
#line 12193 "semantics.c"
  return nia;
  /* Extraction: SDC1b
       #undef do-not-use-icache
       6.0x3d,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#line 12202 "semantics.c"
}

#endif /* _SEMANTICS_C_*/
